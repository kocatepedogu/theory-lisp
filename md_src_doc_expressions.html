<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Theory Lisp: Expressions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Theory Lisp
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_src_doc_expressions.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Expressions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md29"></a>
Function Evaluation Expression</h1>
<p>A function evaluation consists of a function (first expression) and function arguments (remaining expressions). Function arguments are fully evaluated before the function is called. The evaluation order is always left to right.</p>
<p>'load' is a builtin function that executes another Theory Lisp source at runtime.</p>
<div class="fragment"><div class="line">(load &quot;file.tl&quot;)</div>
</div><!-- fragment --><p>'+' is a builtin arithmetic function</p>
<div class="fragment"><div class="line">; yields 6</div>
<div class="line">(+ 1 2 3)</div>
</div><!-- fragment --><p>'display' is a builtin function that prints its arguments.</p>
<div class="fragment"><div class="line">; prints 1,2,3</div>
<div class="line">(display 1 &quot;,&quot; 2 &quot;,&quot; 3)</div>
</div><!-- fragment --><p>'begin' is a builtin function that returns its last argument. It is used to implement sequencing in Theory Lisp.</p>
<div class="fragment"><div class="line">; Prints 123</div>
<div class="line">(begin</div>
<div class="line">  (display 1)</div>
<div class="line">  (display 2)</div>
<div class="line">  (display 3)</div>
<div class="line">)</div>
</div><!-- fragment --><p><b>Expanding a list object in function evaluation</b></p>
<p>Suppose that a function named 'func' takes 3 arguments, and the values that are going to be passed are currently stored in a list named 'lst'.</p>
<p>The obvious way to pass the list contents is the following:</p>
<div class="fragment"><div class="line">(func (car lst) (cadr lst) (car (cddr lst)))</div>
</div><!-- fragment --><p>This is long and error-prone. Theory Lisp provides % operator to expand a list in a function evaluation, so that the same thing can be done in a much shorter way. Also, the number of formal parameters does not need to be known for using the function. The function may even be variadic, in which case % can be used for forwarding variadic arguments.</p>
<div class="fragment"><div class="line">(func %lst)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md30"></a>
Define Expression</h1>
<p>Define expression creates a variable in the global scope.</p>
<div class="fragment"><div class="line">(define x 3)</div>
<div class="line">; x is 3</div>
<div class="line">(define y (+ 2 3))</div>
<div class="line">; y is 5</div>
</div><!-- fragment --><p>define can be used to modify an existing global variable</p>
<div class="fragment"><div class="line">(define x 3)</div>
<div class="line">; x is initially 3</div>
<div class="line">(define x (+ x 1))</div>
<div class="line">; x is now 4</div>
</div><!-- fragment --><p>define can be used inside another expression. Define expressions always yield (void)</p>
<div class="fragment"><div class="line">(display (define x 1))</div>
<div class="line">; Prints (void)</div>
<div class="line">(display x)</div>
<div class="line">; Prints 1</div>
</div><!-- fragment --><p>define can be used to write imperative code as it is allowed to mutate existing variables.</p>
<h1><a class="anchor" id="autotoc_md31"></a>
Let Expression</h1>
<p>Let expression is used to declare local variables. A let expression consists of a list of variable declarations and a body.</p>
<p>The list of variable declarations can be empty </p><div class="fragment"><div class="line">(let () (+ 2 3)) ; yields 5</div>
</div><!-- fragment --><p> The list of variable declarations can contain one or more variables </p><div class="fragment"><div class="line">(let ((x 1) (y 2)) (+ x y)) ; yields 3</div>
</div><!-- fragment --><p> Variables with the same name in outer scope are not affected. </p><div class="fragment"><div class="line">(define x 1)</div>
<div class="line"> </div>
<div class="line">; Prints 2</div>
<div class="line">(let ((x 2)) </div>
<div class="line">   (display x))</div>
<div class="line">   </div>
<div class="line">; Prints 1</div>
<div class="line">(display x)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md32"></a>
Set Expression</h1>
<p>Set expression modifies an existing variable, or creates a new local variable if the variable with the given name does not exist.</p>
<p>Creates x in the local stack frame of let expression. Displayed value is 1.</p>
<div class="fragment"><div class="line">(let ()</div>
<div class="line">  (begin</div>
<div class="line">    (set! x 1)</div>
<div class="line">    (display x)))</div>
</div><!-- fragment --><p>Local x is initialized to 1. set! modifies the value of x to 2. Displayed value is 2.</p>
<div class="fragment"><div class="line">(let ((x 1))</div>
<div class="line">  (begin</div>
<div class="line">    (set! x (+ x 1))</div>
<div class="line">    (display x)))</div>
</div><!-- fragment --><p>Global x is initialized to 1. set! tries to find x in the local scope without success, so it continues to search in outer scopes. It finds global x and modifies its value to 2. Displayed value is 2</p>
<div class="fragment"><div class="line">(define x 1)</div>
<div class="line">(let ()</div>
<div class="line">  (set! x (+ x 1))</div>
<div class="line">(display x)</div>
</div><!-- fragment --><p>set! can be used to write imperative code as it is allowed to mutate existing variables.</p>
<h1><a class="anchor" id="autotoc_md33"></a>
If Expression</h1>
<p>If expression provides branching in Theory Lisp. The expression consists of a condition expression, an expression that gets evaluated when the condition is true, and an expression that gets evaluated when the condition is false.</p>
<div class="fragment"><div class="line">(if #t 1 2) ; yields 1</div>
<div class="line">(if #f 1 2) ; yields 2</div>
</div><!-- fragment --><div class="fragment"><div class="line">(if #t (display 1) (display 2)) ; prints 1</div>
<div class="line">(if #f (display 1) (display 2)) ; prints 2</div>
</div><!-- fragment --><p>Using a value other than boolean as condition causes a runtime error. This is different from most other Lisp variants.</p>
<div class="fragment"><div class="line">(if null 1 2) ; throws a runtime error</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md34"></a>
Cond Expression</h1>
<p>Cond expression is used to implement multiway branching. The expression consists of a list of pairs. Each pair has a condition followed by an expression that gets evaluated when the condition is true.</p>
<div class="fragment"><div class="line">(define x 0.5)</div>
<div class="line"> </div>
<div class="line">; yields 1</div>
<div class="line">(cond</div>
<div class="line">  ((&lt; x 0) -1)</div>
<div class="line">  ((= x 0) 0)</div>
<div class="line">  ((&gt; x 0) 1)</div>
<div class="line">)</div>
</div><!-- fragment --><p>'else' is an alias for #t defined in "util.tl". It can be used as a default case in cond expression.</p>
<div class="fragment"><div class="line">(include &quot;util.tl&quot;)</div>
<div class="line"> </div>
<div class="line">(cond</div>
<div class="line">  ((&lt; x 0) -1)</div>
<div class="line">  (else 1)</div>
<div class="line">)</div>
</div><!-- fragment --><p>Cond expression yields (void) if none of the conditions is satisfied.</p>
<div class="fragment"><div class="line">(define x 0)</div>
<div class="line"> </div>
<div class="line">; yields (void)</div>
<div class="line">(cond</div>
<div class="line">  ((&lt; x 0) -1)</div>
<div class="line">  ((&gt; x 0) 1)</div>
<div class="line">)</div>
</div><!-- fragment --><p>Similar to if expression, condition must evaluate to a boolean value. Using another type as condition causes a runtime error.</p>
<div class="fragment"><div class="line">(cond</div>
<div class="line">  (null 0) ; throws a runtime error</div>
<div class="line">  (else 1)</div>
<div class="line">)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md35"></a>
Lambda Expression</h1>
<p>Lambda expression is used to create a function. It consists of</p><ol type="1">
<li>an optional prefix arity</li>
<li>an optional capture list</li>
<li>a formal parameter list and</li>
<li>a body.</li>
</ol>
<p><b>Lambdas with Fixed Number Of Parameters</b></p>
<p>The following is a function with a single argument that computes the factorial of a given number. This is also valid code in Scheme.</p>
<div class="fragment"><div class="line">(define factorial</div>
<div class="line">  (lambda (n)</div>
<div class="line">    (if (= 0 n)</div>
<div class="line">      1</div>
<div class="line">      (* n (factorial (- n 1))))))</div>
</div><!-- fragment --><p>The number of actual arguments must exactly match the number of formal parameters. Otherwise, a runtime error is thrown.</p>
<div class="fragment"><div class="line">(define func</div>
<div class="line">  (lambda (x y)</div>
<div class="line">    (+ x y)))</div>
<div class="line">    </div>
<div class="line">(func 1 2 3) ; Runtime error</div>
<div class="line">(func 1 2) ; OK</div>
<div class="line">(func 1) ; Runtime error</div>
</div><!-- fragment --><p>The same factorial function can be written with an explicit prefix arity, but this is not required. Prefix arity is automatically set to the number of parameters when it is not given.</p>
<div class="fragment"><div class="line">(define factorial</div>
<div class="line">  (lambda\1 (n)</div>
<div class="line">    (if (= 0 n)</div>
<div class="line">      1</div>
<div class="line">      (* n (factorial (- n 1))))))</div>
</div><!-- fragment --><p>If the given prefix arity does not match the number of formal parameters, a parser error is generated. This can be used in functions with too many parameters to ensure that the number of parameters is correct.</p>
<div class="fragment"><div class="line">(define func</div>
<div class="line">  (lambda\3 (x y) ; Parser error. Real arity is 2, not 3.</div>
<div class="line">    (+ x y)))</div>
</div><!-- fragment --><p><b>Lambdas with Variable Number of Parameters</b></p>
<p>Variadic lambdas can take unlimited number of arguments. A variadic lambda is defined by using ellipsis '...' in the formal parameter list. The list of actual variadic arguments is stored in the automatically generated local variable named 'va_args'.</p>
<p>The following is a variadic function that returns the sum of arguments. It also shows the use of % for forwarding variadic arguments. </p><div class="fragment"><div class="line">(define sum</div>
<div class="line">  (lambda (...)</div>
<div class="line">    (if (null? va_args)</div>
<div class="line">      0</div>
<div class="line">      (+ (car va_args) (sum %(cdr va_args)))</div>
<div class="line">    )</div>
<div class="line">  )</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">(sum 1 2 3 4) ; yields 10</div>
</div><!-- fragment --><p>It is possible for a lambda to have some fixed parameters before the ellipsis. For example, the following function finds the sum of variadic arguments and then multiplies the result with the given coefficient</p>
<div class="fragment"><div class="line">(define func</div>
<div class="line">  (lambda (coeff ...)</div>
<div class="line">    (* coeff (+ %va_args))</div>
<div class="line">  )</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">(func 2 1 2 3) ; yields 12</div>
</div><!-- fragment --><p>The number of actual arguments must be at least equal to the number of fixed parameters, and it can be larger.</p>
<div class="fragment"><div class="line">(define func</div>
<div class="line">  (lambda (x y ...)</div>
<div class="line">    (+ x y %va_args)</div>
<div class="line">  )</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">(func 1) ; runtime error</div>
<div class="line">(func 1 2) ; yields 3</div>
<div class="line">(func 1 2 3) ; yields 6</div>
</div><!-- fragment --><p>The prefix arity of a variadic lambda is automatically set to the number of fixed parameters. If the function does not have any fixed parameters, the prefix arity is set to 0. This can be overriden by writing a backslash symbol and an arity value like below. The prefix arity is allowed to be any value greater than or equal to the number of fixed parameters.</p>
<div class="fragment"><div class="line">(define multiply)</div>
<div class="line">  (lambda\2 (...)</div>
<div class="line">    (* %va_args)))</div>
</div><!-- fragment --><p>The prefix arity only matters if the lambda is used inside a Polish notation expression.</p>
<p><b>Capture List</b></p>
<p>Capture list contains the names of variables whose values will be captured from the environment where the lambda is created. Square brackets are used to write a capture list.</p>
<div class="fragment"><div class="line">(define make-predicate</div>
<div class="line">  (lambda (low high)</div>
<div class="line">    (lambda [low high] (x)</div>
<div class="line">      (and (&gt; x low) (&lt; x high)))))</div>
</div><!-- fragment --><p>The function make-predicate returns a predicate that takes a number x and returns true if it is in the specified range. For example,</p>
<div class="fragment"><div class="line">(define pred</div>
<div class="line">  (make-predicate 10 30))</div>
</div><!-- fragment --><p>pred is a function with a single argument that returns true if its argument is in the interval (10, 30).</p>
<div class="fragment"><div class="line">(pred 20) ; yields #t</div>
<div class="line">(pred 50) ; yields #f</div>
</div><!-- fragment --><p>The capture list [low high] in the first code block tells the interpreter that the values of low and high at the moment the procedure is created must be incorporated into the closure of the procedure. If the capture list were not used, (pred 20) would throw an error because it would not be able to find the variables low and high.</p>
<h1><a class="anchor" id="autotoc_md36"></a>
Polish Notation Expression</h1>
<p>Polish notation expression is another way to define functions, but it is usually much shorter than equivalent lambda expressions. For example,</p>
<div class="fragment"><div class="line">(lambda (x y z) (+ x (* y z)))</div>
</div><!-- fragment --><p>can be written as</p>
<div class="fragment"><div class="line">{+ $1 * $2 $3}</div>
</div><!-- fragment --><p><b>Syntax</b></p>
<p>PN expression body contains procedure objects and objects that are arguments to those procedures.</p>
<p>Functions defined using Polish notation are always variadic. Each argument can be accessed through automatically generated local variables $1, $2, $3, $4, ... The total number of arguments is stored in the variable 'nargs'.</p>
<div class="fragment"><div class="line">(define f1 </div>
<div class="line">  {display + $2 $3})</div>
<div class="line">(define f2</div>
<div class="line">  {display nargs})</div>
<div class="line"> </div>
<div class="line">(f1 1 2 3) ; Prints 5</div>
<div class="line">(f2 1 2 3) ; Prints 3</div>
</div><!-- fragment --><p><b>Implicit Insertions</b></p>
<p>Each procedure inside the PN expression body expects as many arguments as its prefix arity. When some arguments are missing, the missing arguments are inserted from the left using the values of $1, $2, $3,... Examples are more clear than a formal description.</p>
<p><b>Example 1</b></p>
<p>The prefix arity of &gt; is 2, so it expects two arguments like below.</p>
<div class="fragment"><div class="line">{&gt; $1 3}</div>
</div><!-- fragment --><p>The following is also valid and equivalent.</p>
<div class="fragment"><div class="line">{&gt; 3}</div>
</div><!-- fragment --><p><b>Example 2</b></p>
<p>The prefix arity of * is 2, so it expects two arguments. One argument is $1 which becomes 6, and the other is - 5 3 which yields 2. The entire expression yields 12.</p>
<div class="fragment"><div class="line">({* $1 - 5 3} 6)</div>
</div><!-- fragment --><p>The following, where the first argument of * is missing, is also valid and equivalent.</p>
<div class="fragment"><div class="line">({* - 5 3} 6)</div>
</div><!-- fragment --><p><b>Example 3</b></p>
<p>The prefix arity of - is 2, so it expects two arguments like below. The entire expression yields 4.</p>
<div class="fragment"><div class="line">({- $1 $2} 7 3)</div>
</div><!-- fragment --><p>The following is also valid and equivalent. In this case both $1 and $2 are inserted.</p>
<div class="fragment"><div class="line">({-} 7 3)</div>
</div><!-- fragment --><p>Unless the operation is trivial such as {= 2}, {&gt; 3}, {&lt; 0} it is not a good idea to write functions that depend on implicit insertion of arguments. It reduces readability and is prone to errors. When operations are trivial, however; using implicit insertions makes large programs more readable.</p>
<p>Warning: If there are multiple procedures with missing arguments in a PN expression, the behaviour is undefined. Use implicit insertions only if just a single procedure has missing arguments. Also, always ensure that the missing arguments are on the left, not on the right.</p>
<p><b>PN expressions with a single value</b></p>
<p>A PN expression with a single object in its body (not a procedure object) is equivalent to a lambda that returns that value.</p>
<div class="fragment"><div class="line">{123}</div>
</div><!-- fragment --><p> is equivalent to the lambda </p><div class="fragment"><div class="line">(lambda (...) 123)</div>
</div><!-- fragment --><p>This property can be used to embed an S-expression inside a PN expression. </p><div class="fragment"><div class="line">{(if $1 (+ $2 $3) (- $2 $3))}</div>
<div class="line">{(set! x 1)}</div>
</div><!-- fragment --><p>Similar to lambda expressions, a capture list can be added at the beginning of the PN expression</p>
<div class="fragment"><div class="line">(define make-predicate</div>
<div class="line">  (lambda (low high)</div>
<div class="line">    {[low high] and &gt; $1 low &lt; $1 high}))</div>
</div><!-- fragment --><p>PN expressions reduce length of functions significantly, but there are also some drawbacks. Getting rid of parenthesis, and using implicit insertions require restrictions that does not exist in lambdas.</p>
<p>Every procedure in the body must take fixed number of parameters. To be able to use a variadic function in PN expressions, a reasonable prefix arity must be given in its definition. Then the procedure can be used as if it had a fixed number of parameters with that arity. Builtin arithmetic operators are variadic, and accept zero or more arguments, but they have a prefix arity of 2.</p>
<p><b>PN expression inside PN expression</b></p>
<p>Since procedures created using PN expressions are always variadic, using a PN procedure inside another PN expression requires a prefix arity.</p>
<p>When no prefix arity is given, the prefix arity of a PN expression is automatically set to 0. This can be overriden by writing the prefix arity after a backslash similar to lambda expressions. The prefix arity of the following PN expression is 2.</p>
<div class="fragment"><div class="line">{\2 + $1 $2}</div>
</div><!-- fragment --><p>Now, it is possible to use this PN procedure inside another PN expression</p>
<div class="fragment"><div class="line">{{\2 + $1 $2} 3 4}</div>
</div><!-- fragment --><p><b>Using a procedure as argument to another procedure</b></p>
<p>If a procedure object is an argument to another procedure in a PN expression, wrap it using the 'wrap' function defined in 'util.tl'. For example, in the following code,</p>
<div class="fragment"><div class="line">(define increment (lambda (x) (+ x 1)))</div>
<div class="line">(define list-increment {map increment $1})</div>
<div class="line">(list-increment (list 1 2 3))</div>
<div class="line">; throws error</div>
</div><!-- fragment --><p>it seems that 'increment' and '$1' are going to be passed as arguments to 'map'. What actually happens is that '$1' is passed to 'increment', which throws an error. The solution to this problem is to wrap 'increment'.</p>
<div class="fragment"><div class="line">(define increment (lambda (x) (+ x 1)))</div>
<div class="line">(define list-increment {map (wrap increment) $1})</div>
<div class="line">(list-increment (list 1 2 3))</div>
<div class="line">; yields a list with values 2 3 4</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md37"></a>
Automaton Expression</h1>
<p>An automaton in Theory Lisp is a machine that can be used to simulate deterministic Turing machines and finite state machines. Automatons take tapes as arguments and return final tape contents combined with a decision value.</p>
<p>An automaton expression consists of</p><ol type="1">
<li>An arity (number of tapes that the machine operates on)</li>
<li>An optional capture list</li>
<li>A list of states</li>
</ol>
<p>An automaton expression begins with the keyword 'automaton' followed by an arity that denotes the number of tapes the machine operates on. The arity is mandatory. In the following automaton, '\1' means that machine uses a single tape.</p>
<div class="fragment"><div class="line">(automaton\1</div>
<div class="line">   STATES ARE WRITTEN HERE</div>
<div class="line">)</div>
</div><!-- fragment --><p>Frequently, it is necessary to generate automatons based on some parameter at runtime. An optional capture list can be used.</p>
<div class="fragment"><div class="line">(define make-automaton</div>
<div class="line">  (lambda (some-parameter)</div>
<div class="line">    (automaton\1 [some-parameter]</div>
<div class="line">      STATES ARE WRITTEN HERE</div>
<div class="line">    )</div>
<div class="line">  )</div>
<div class="line">)</div>
</div><!-- fragment --><p>Each state begins with a state name followed by a sequence of transitions. The following machine has two states named q0 and q1. The first state is always the start state.</p>
<div class="fragment"><div class="line">(automaton\1</div>
<div class="line">  (q0</div>
<div class="line">    TRANSITIONS ARE WRITTEN HERE</div>
<div class="line">  )</div>
<div class="line">  (q1</div>
<div class="line">    TRANSITIONS ARE WRITTEN HERE</div>
<div class="line">  )</div>
<div class="line">)</div>
</div><!-- fragment --><p>Each transition consists of a transition condition (a function), head operations for each tape, and an identifier that denotes the next state.</p>
<div class="fragment"><div class="line">(automaton\1</div>
<div class="line">  (q0</div>
<div class="line">    (CONDITION HEAD-OPERATIONS NEXT-STATE)</div>
<div class="line">    (CONDITION HEAD-OPERATIONS NEXT-STATE)</div>
<div class="line">  )</div>
<div class="line">  (q1</div>
<div class="line">    (CONDITION HEAD-OPERATIONS NEXT-STATE)</div>
<div class="line">    (CONDITION HEAD-OPERATIONS NEXT-STATE)</div>
<div class="line">  )</div>
<div class="line">)</div>
</div><!-- fragment --><p>There are four possible head operations.</p><ol type="1">
<li>Writing a symbol under the current tape head</li>
<li>Moving the tape head to the right</li>
<li>Moving the tape head to the left</li>
<li>Doing nothing on the tape</li>
</ol>
<p>In the first case, the value to be written is used as the head operation. The value can be of any type.</p>
<div class="fragment"><div class="line">(CONDITION &quot;an example value&quot; NEXT-STATE)</div>
</div><!-- fragment --><p>In the second case, "-&gt;" keyword is used to denote moving right.</p>
<div class="fragment"><div class="line">(CONDITION -&gt; NEXT-STATE)</div>
</div><!-- fragment --><p>In the third case, "&lt;-" keyword is used to denote moving left.</p>
<div class="fragment"><div class="line">(CONDITION &lt;- NEXT-STATE)</div>
</div><!-- fragment --><p>In the last case, "." is used to denote doing nothing.</p>
<div class="fragment"><div class="line">(CONDITION . NEXT-STATE)</div>
</div><!-- fragment --><p>In finite state machines, the tape is never modified, and the head can only move right. Therefore, all head operations are simply '-&gt;'</p>
<div class="fragment"><div class="line">(automaton\1</div>
<div class="line">  (q0</div>
<div class="line">    (CONDITION -&gt; NEXT-STATE)</div>
<div class="line">    (CONDITION -&gt; NEXT-STATE)</div>
<div class="line">  )</div>
<div class="line">  (q1</div>
<div class="line">    (CONDITION -&gt; NEXT-STATE)</div>
<div class="line">    (CONDITION -&gt; NEXT-STATE)</div>
<div class="line">  )</div>
<div class="line">)</div>
</div><!-- fragment --><p>If there are multiple tapes, the head operation for each tape must be given. An example automaton with 2 tapes:</p>
<div class="fragment"><div class="line">(automaton\2</div>
<div class="line">  (q0</div>
<div class="line">    (CONDITION . . NEXT-STATE)</div>
<div class="line">    (CONDITION &lt;- -&gt; NEXT-STATE)</div>
<div class="line">  )</div>
<div class="line">  (q1</div>
<div class="line">    (CONDITION -&gt; &lt;- NEXT-STATE)</div>
<div class="line">    (CONDITION &quot;a&quot; &quot;b&quot; NEXT-STATE)</div>
<div class="line">  )</div>
<div class="line">)</div>
</div><!-- fragment --><p>Next state can be one of the following</p><ol type="1">
<li>an identifier that denotes the name of the next state</li>
<li>keyword 'self'</li>
<li>keyword 'next'</li>
<li>keyword 'halt'</li>
<li>keyword 'accept'</li>
<li>keyword 'reject'</li>
</ol>
<p>If an identifier is used as the next state name, the machine enters into that state when it follows the transition.</p>
<div class="fragment"><div class="line">(automaton\1</div>
<div class="line">  (q0</div>
<div class="line">    (CONDITION -&gt; q0)</div>
<div class="line">    (CONDITION -&gt; q1)</div>
<div class="line">  )</div>
<div class="line">  (q1</div>
<div class="line">    (CONDITION -&gt; q1)</div>
<div class="line">    (CONDITION -&gt; q0)</div>
<div class="line">  )</div>
<div class="line">)</div>
</div><!-- fragment --><p>The keyword 'self' can be used to enter the current state again.</p>
<div class="fragment"><div class="line">(automaton\1</div>
<div class="line">  (q0</div>
<div class="line">    (CONDITION -&gt; self)</div>
<div class="line">    (CONDITION -&gt; q1)</div>
<div class="line">  )</div>
<div class="line">  (q1</div>
<div class="line">    (CONDITION -&gt; self)</div>
<div class="line">    (CONDITION -&gt; q0)</div>
<div class="line">  )</div>
<div class="line">)</div>
</div><!-- fragment --><p>The keyword 'next' can be used to enter the state that follows the current state.</p>
<div class="fragment"><div class="line">(automaton\1</div>
<div class="line">  (q0</div>
<div class="line">    (CONDITION -&gt; self)</div>
<div class="line">    (CONDITION -&gt; next)</div>
<div class="line">  )</div>
<div class="line">  (q1</div>
<div class="line">    (CONDITION -&gt; self)</div>
<div class="line">    (CONDITION -&gt; q0)</div>
<div class="line">  )</div>
<div class="line">)</div>
</div><!-- fragment --><p>Using 'self' and 'next' makes it possible to write more "position independent" states.</p>
<p><b>Halting</b></p>
<p>In Theory Lisp, automatons can simulate both machines that compute by leaving a result on the tape and machines that accept or reject a given input.</p>
<p>'halt', 'accept', and 'reject' all terminate the execution of the machine, but their meanings are different.</p>
<ul>
<li>'halt', means that the execution is done, and the computed result is on the tape.</li>
<li>'accept' means that the execution is done, and the machine has decided that the input is accepted.</li>
<li>'reject' means that the execution is done, and the machine has decided that the input is rejected.</li>
</ul>
<p>This machine is the same as the previous one, except that it accepts if the end of input occurs in the q0 state, and it rejects if the end of input occurs in the q1 state.</p>
<div class="fragment"><div class="line">(automaton\1</div>
<div class="line">  (q0</div>
<div class="line">    (CONDITION -&gt; self)</div>
<div class="line">    (CONDITION -&gt; next)</div>
<div class="line">    (END-OF-INPUT-CONDITION . accept)</div>
<div class="line">  )</div>
<div class="line">  (q1</div>
<div class="line">    (CONDITION -&gt; self)</div>
<div class="line">    (CONDITION -&gt; q0)</div>
<div class="line">    (END-OF-INPUT-CONDITION . reject)</div>
<div class="line">  )</div>
<div class="line">)</div>
</div><!-- fragment --><p><b>Transition Conditions</b></p>
<p>A transition condition is a function that takes current symbols under tape heads as arguments, and returns a boolean value. When a PN expression is used as a transition condition, $1 refers to the current symbol on the first tape, $2 refers to the current symbol on the second tape, and so on.</p>
<p>The machine now does summation in modulo 2.</p>
<div class="fragment"><div class="line">(automaton\1</div>
<div class="line">  (q0</div>
<div class="line">    ({= $1 0} -&gt; self)</div>
<div class="line">    ({= $1 1} -&gt; next)</div>
<div class="line">    (END-OF-INPUT-CONDITION . accept)</div>
<div class="line">  )</div>
<div class="line">  (q1</div>
<div class="line">    ({= $1 0} -&gt; self)</div>
<div class="line">    ({= $1 1} -&gt; q0)</div>
<div class="line">    (END-OF-INPUT-CONDITION . reject)</div>
<div class="line">  )</div>
<div class="line">)</div>
</div><!-- fragment --><p>By using the implicit insertion feature of PN expressions, it is possible to get rid of $1's in this machine. Now, it looks more readable.</p>
<div class="fragment"><div class="line">(automaton\1</div>
<div class="line">  (q0</div>
<div class="line">    ({= 0} -&gt; self)</div>
<div class="line">    ({= 1} -&gt; next)</div>
<div class="line">    (END-OF-INPUT-CONDITION . accept)</div>
<div class="line">  )</div>
<div class="line">  (q1</div>
<div class="line">    ({= 0} -&gt; self)</div>
<div class="line">    ({= 1} -&gt; q0)</div>
<div class="line">    (END-OF-INPUT-CONDITION . reject)</div>
<div class="line">  )</div>
<div class="line">)</div>
</div><!-- fragment --><p>Finally, it is required to write a condition that recognizes the end of input. When the machine runs out of the initially given tape contents by moving right, it extends the tape by blank symbols. This is how infinite tapes of Turing machines are simulated. Therefore, it is reasonable to stop when a blank symbol is read from the tape. The blank symbol 'blank' is defined in automata.tl</p>
<div class="fragment"><div class="line">(include &quot;automata.tl&quot;)</div>
<div class="line"> </div>
<div class="line">(automaton\1</div>
<div class="line">  (q0</div>
<div class="line">    ({= 0} -&gt; self)</div>
<div class="line">    ({= 1} -&gt; next)</div>
<div class="line">    ({= blank} . accept)</div>
<div class="line">  )</div>
<div class="line">  (q1</div>
<div class="line">    ({= 0} -&gt; self)</div>
<div class="line">    ({= 1} -&gt; q0)</div>
<div class="line">    ({= blank} . reject)</div>
<div class="line">  )</div>
<div class="line">)</div>
</div><!-- fragment --><ul>
<li>Transitions conditions are tested in the order they appear.</li>
<li>At least one transition condition must be satisfied. If none of the transitions is satisfied, a runtime error is thrown because the machine must either halt or go to some other state.</li>
</ul>
<p><b>State Outputs</b></p>
<p>A state output is an optional PN expression that follows the state name. State outputs are executed when the machine enters a state. They can be used to display or extract information.</p>
<div class="fragment"><div class="line">(include &quot;automata.tl&quot;)</div>
<div class="line">(include &quot;util.tl&quot;)</div>
<div class="line"> </div>
<div class="line">(define DFA</div>
<div class="line">  (automaton\1</div>
<div class="line">    (q0 {println &quot;Entered q0&quot;}</div>
<div class="line">        ({= 0} -&gt; self)</div>
<div class="line">        ({= 1} -&gt; next)</div>
<div class="line">        ({= blank} . accept))</div>
<div class="line">    (q1 {println &quot;Entered q1&quot;}</div>
<div class="line">        ({= 0} -&gt; self)</div>
<div class="line">        ({= 1} -&gt; q0)</div>
<div class="line">        ({= blank} . reject))</div>
<div class="line">  )</div>
<div class="line">)</div>
</div><!-- fragment --><p><b>Transition Outputs</b></p>
<p>A transition output is an optional PN expression that is executed when the machine follows a transition. Transition outputs can be used to display or extract information. They are written immediately after a transition.</p>
<div class="fragment"><div class="line">(include &quot;automata.tl&quot;)</div>
<div class="line">(include &quot;util.tl&quot;)</div>
<div class="line"> </div>
<div class="line">(define DFA</div>
<div class="line">  (automaton\1</div>
<div class="line">    (q0 {println &quot;Entered q0&quot;}</div>
<div class="line">        ({= 0} -&gt; self) {println &quot;q0-&gt;q0&quot;}</div>
<div class="line">        ({= 1} -&gt; next) {println &quot;q0-&gt;q1&quot;}</div>
<div class="line">        ({= blank} . accept)</div>
<div class="line">    )</div>
<div class="line">    (q1 {println &quot;Entered q1&quot;}</div>
<div class="line">        ({= 0} -&gt; self) {println &quot;q1-&gt;q1&quot;}</div>
<div class="line">        ({= 1} -&gt; q0) {println &quot;q1-&gt;q0&quot;}</div>
<div class="line">        ({= blank} . reject)</div>
<div class="line">    )</div>
<div class="line">  )</div>
<div class="line">)</div>
</div><!-- fragment --><p><b>Running an automaton</b></p>
<p>An automaton expression evaluates to a procedure object just like lambdas and PN expressions. However, the input format of an automaton procedure is not arbitrary. An automaton takes tapes as arguments.</p>
<p>Each tape is a list whose first element is the head position and remaining elements are the tape contents. The leftmost symbol in the tape must be the left-end symbol. To run the above automaton, the following tape can be used. 'make-tape-noblank' from 'automata.tl' creates a tape with given contents.</p>
<div class="fragment"><div class="line">(DFA (make-tape-noblank 0 1 1 0 1))</div>
</div><!-- fragment --><p>The output will be</p>
<div class="fragment"><div class="line">Entered q0</div>
<div class="line">q0-&gt;q0</div>
<div class="line">Entered q0</div>
<div class="line">q0-&gt;q1</div>
<div class="line">Entered q1</div>
<div class="line">q1-&gt;q0</div>
<div class="line">Entered q0</div>
<div class="line">q0-&gt;q0</div>
<div class="line">Entered q0</div>
<div class="line">q0-&gt;q1</div>
<div class="line">Entered q1</div>
<div class="line">(cons -1 (cons (cons 6 (cons #&lt;void&gt; (cons 0 (cons 1 (cons 1 (cons 0 (cons 1 (cons null null)))))))) null))</div>
</div><!-- fragment --><p>The final line is the result of the machine. It contains the decision that the machine has made and the final tape contents of each tape. To extract these information easily, there are get-decision, get-tapes, get-head, get-contents, tape-tostring functions defined in "automata.tl"</p>
<div class="fragment"><div class="line">; Run machine</div>
<div class="line">(define machine-result</div>
<div class="line">  (DFA (make-tape-noblank 0 1 1 0 1)))</div>
<div class="line"> </div>
<div class="line">; Extract results</div>
<div class="line">(define decision (get-decision machine-result))</div>
<div class="line">(define tape (car (get-tapes machine-result)))</div>
<div class="line">(define head-position (get-head tape))</div>
<div class="line">(define tape-contents (get-contents tape))</div>
<div class="line"> </div>
<div class="line">(println &quot;Decision is &quot; decision)</div>
<div class="line">(println &quot;Final head position is &quot; head-position)</div>
<div class="line">(println &quot;Final tape contents : &quot; (tape-tostring tape-contents))</div>
</div><!-- fragment --><p>The output will be</p>
<div class="fragment"><div class="line">Entered q0</div>
<div class="line">q0-&gt;q0</div>
<div class="line">Entered q0</div>
<div class="line">q0-&gt;q1</div>
<div class="line">Entered q1</div>
<div class="line">q1-&gt;q0</div>
<div class="line">Entered q0</div>
<div class="line">q0-&gt;q0</div>
<div class="line">Entered q0</div>
<div class="line">q0-&gt;q1</div>
<div class="line">Entered q1</div>
<div class="line">Decision is -1</div>
<div class="line">Final head position is 6</div>
<div class="line">Final tape contents : #&lt;void&gt; 0 1 1 0 1 null</div>
</div><!-- fragment --><p>Decision being -1 means that the input is rejected as expected, because "0 + 1 + 1 + 0 + 1" is equal to 1 in modulo 2, which leaves the machine in the q1 state. If the machine had accepted the input, the decision would be +1. If the machine halts with "halt" keyword without making any decision, the decision becomes 0. The tape contents has not been modified except that a blank symbol (which is null) is inserted at the right end of the tape when the machine moved out of the initial tape contents, and the final tape head is on top of that null symbol.</p>
<p><b>Composite Machines</b></p>
<p>Using everything up to now, we can write complex finite state machines and DFAs, but this is not the preferred method of designing Turing machines even though it is possible. Instead of writing every single state and transition, composite machines can be constructed from simpler machines by using them as base machines.</p>
<p>If a state has a "base machine", it is written immediately after the state name with a colon. q0:R means that when the machine enters the q0 state, it first executes the machine R on the current tapes, and then starts executing the transitions of q0.</p>
<p>The previous machine is rewritten using the right moving machine 'R' (defined in automata.tl) as base machines of both states. All head operations are replaced with dots because they are already done by the base machine.</p>
<div class="fragment"><div class="line">(include &quot;automata.tl&quot;)</div>
<div class="line">(include &quot;util.tl&quot;)</div>
<div class="line"> </div>
<div class="line">(define DFA</div>
<div class="line">  (automaton\1</div>
<div class="line">    (q0:R {println &quot;Entered q0&quot;}</div>
<div class="line">        ({= 0} . self) {println &quot;q0-&gt;q0&quot;}</div>
<div class="line">        ({= 1} . next) {println &quot;q0-&gt;q1&quot;}</div>
<div class="line">        ({= blank} . accept)</div>
<div class="line">    )</div>
<div class="line">    (q1:R {println &quot;Entered q1&quot;}</div>
<div class="line">        ({= 0} . self) {println &quot;q1-&gt;q1&quot;}</div>
<div class="line">        ({= 1} . q0) {println &quot;q1-&gt;q0&quot;}</div>
<div class="line">        ({= blank} . reject)</div>
<div class="line">    )</div>
<div class="line">  )</div>
<div class="line">)</div>
</div><!-- fragment --><p>One difference is that now the machine starts by moving to right immediately. Executing the transitions of q0 occurs afterwards. The previous tape format can no longer be used because the machine will skip the first digit on the tape.</p>
<p>The solution is to use make-tape instead of make-tape-noblank. make-tape creates a tape that has the following format:</p><ol type="1">
<li>First symbol is the left-end symbol</li>
<li>Second symbol is a blank symbol</li>
<li>Remaining cells contain given tape contents.</li>
<li>Tape head is initially on the second symbol (the blank symbol)</li>
</ol>
<div class="fragment"><div class="line">; Run machine</div>
<div class="line">(define machine-result</div>
<div class="line">  (DFA (make-tape 0 1 1 0 1)))</div>
<div class="line"> </div>
<div class="line">; Extract results</div>
<div class="line">(define decision (get-decision machine-result))</div>
<div class="line">(define tape (car (get-tapes machine-result)))</div>
<div class="line">(define head-position (get-head tape))</div>
<div class="line">(define tape-contents (get-contents tape))</div>
<div class="line"> </div>
<div class="line">(println &quot;Decision is &quot; decision)</div>
<div class="line">(println &quot;Final head position is &quot; head-position)</div>
<div class="line">(println &quot;Final tape contents : &quot; (tape-tostring tape-contents))</div>
</div><!-- fragment --><p>The output will be</p>
<div class="fragment"><div class="line">Entered q0</div>
<div class="line">q0-&gt;q0</div>
<div class="line">Entered q0</div>
<div class="line">q0-&gt;q1</div>
<div class="line">Entered q1</div>
<div class="line">q1-&gt;q0</div>
<div class="line">Entered q0</div>
<div class="line">q0-&gt;q0</div>
<div class="line">Entered q0</div>
<div class="line">q0-&gt;q1</div>
<div class="line">Entered q1</div>
<div class="line">Decision is -1</div>
<div class="line">Final head position is 7</div>
<div class="line">Final tape contents : #&lt;void&gt; null 0 1 1 0 1 null</div>
</div><!-- fragment --><p>The same decision is made. The tape head position is increased by one because of the additional blank symbol at the beginning, but it is still on the final blank symbol.</p>
<p><b>Simplified Code</b></p>
<p>The following is a simplified version that just runs the machine and gets the decision without any other output.</p>
<div class="fragment"><div class="line">(include &quot;automata.tl&quot;)</div>
<div class="line"> </div>
<div class="line">(define DFA</div>
<div class="line">  (automaton\1</div>
<div class="line">    (q0:R</div>
<div class="line">        ({= 0} . self)</div>
<div class="line">        ({= 1} . next)</div>
<div class="line">        ({= blank} . accept))</div>
<div class="line">    (q1:R</div>
<div class="line">        ({= 0} . self)</div>
<div class="line">        ({= 1} . q0)</div>
<div class="line">        ({= blank} . reject))))</div>
<div class="line"> </div>
<div class="line">(println &quot;Decision is &quot; </div>
<div class="line">  (get-decision (DFA (make-tape 0 1 1 0 1))))</div>
</div><!-- fragment --><p>This is a very simple example used to demonstrate the usage of automatons. There is a Turing machine example in examples directory that shows how more complicated machines can be constructed.</p>
<p><b>Halting in a base machine</b></p>
<p>If a base machine halts normally using 'halt', the control is transferred to the outer machine and the outer machine continues running. However, if a base machine accepts or rejects, the execution of the outer machine is terminated, and the decision is returned to the original caller that called the outer machine. In the previous examples, the right moving machines do not make decisions, they just halt normally.</p>
<p><b>Markov Chains</b></p>
<p>An automaton can be used to simulate a Markov chain. The difference is that there are no tapes or head operations. The base machines and transition conditions are purely probabilistic. The arity of the automaton is 0, and the automaton is called without any arguments.</p>
<div class="fragment"><div class="line">(include &quot;automata.tl&quot;)</div>
<div class="line">(include &quot;util.tl&quot;)</div>
<div class="line"> </div>
<div class="line">; Total number of steps</div>
<div class="line">(define STEPS 500)</div>
<div class="line"> </div>
<div class="line">; Number of visits for each state</div>
<div class="line">(define A 0)</div>
<div class="line">(define B 0)</div>
<div class="line"> </div>
<div class="line">; Stop condition</div>
<div class="line">(define done?</div>
<div class="line">  {= STEPS + A B})</div>
<div class="line"> </div>
<div class="line">; Automaton</div>
<div class="line">(define MarkovChain</div>
<div class="line">  (automaton\0</div>
<div class="line">    (qA:P {(set! A (+ A 1))}</div>
<div class="line">      (done? accept)</div>
<div class="line">      ({p 0.3} qA)</div>
<div class="line">      ({p 0.7} qB))</div>
<div class="line">    (qB:P {(set! B (+ B 1))}</div>
<div class="line">      (done? reject)</div>
<div class="line">      ({p 0.2} qB)</div>
<div class="line">      ({p 0.8} qA))))</div>
<div class="line"> </div>
<div class="line">; Run automaton</div>
<div class="line">(let ((result (MarkovChain)))</div>
<div class="line">  (println &quot;Decision: &quot; (get-decision result)))</div>
<div class="line"> </div>
<div class="line">; Print results</div>
<div class="line">(let ((pA (* 100.0 (/ A STEPS)))</div>
<div class="line">      (pB (* 100.0 (/ B STEPS))))</div>
<div class="line">  (println &quot;Visit Percentages: qA: &quot; pA &quot; qB: &quot; pB))</div>
</div><!-- fragment --><p>When the machine enters a state, the base machine P gets executed, which generates a random number from standard uniform distribution in the background. Then the state output is called, so the number of visits of the corresponding counter is incremented. Finally, transition conditions are tested, and a next state is choosen based on the probability values. This process continues until the total number of steps becomes equal to STEPS. At the end, the percentages of visits of each state is printed.</p>
<p>The machine P and the function p are not special. They are part of the library and their definitions are in "automata.tl". Different probabilistic base machines and transition conditions can easily be designed. Moreover, it is also possible to design machines that both work on the tape and use probabilistic transitions, but you need write your own base machines and transition conditions to do this. P and p cannot be used if the machine uses tapes.</p>
<p>There is no mechanism to check whether the probabilities in a single state sum up to 1.0. In this example, both 0.3 + 0.7 = 1.0 and 0.2 + 0.8 = 1.0, but this is not enforced. It is programmers' responsibility. If the interpreter fails to find a transition that holds, an error is thrown, but this is not guaranteed to happen as transitions are random.</p>
<p><b>Additional Features</b></p>
<p>If a state with a base machine does not contain any transitions, it immediately goes to the next state after running the base machine. If the next state does not exist, the machine halts without a decision.</p>
<div class="fragment"><div class="line">(automaton\1</div>
<div class="line">  (q1:R) ; goes to q2 after moving right</div>
<div class="line">  (q2:R) ; halts after moving right</div>
<div class="line">)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md38"></a>
Macros</h1>
<p>Macros are functions that transform an expression with a user-defined syntax to a known type of expression. For example, the 'defun' macro defined in "syntax.tl" transforms the expression</p>
<div class="fragment"><div class="line">(defun (f x y)</div>
<div class="line">  (+ x y))</div>
</div><!-- fragment --><p>into the following expression</p>
<div class="fragment"><div class="line">(define f</div>
<div class="line">  (lambda (x y)</div>
<div class="line">    (+ x y)))</div>
</div><!-- fragment --><p>The syntax for using a macro is the same as Scheme, but the syntax for defining a macro is significantly different from other Lisp-like languages. Since Theory Lisp source code is represented as a string, the input to a macro is an arbitrary token stream. A macro reads tokens one by one and generates new source code. The keyword "define-syntax" is used to a define a new macro.</p>
<p>There are 4 builtin functions that macros can use to access the token stream</p><ul>
<li><b>peek-tkn</b> returns the current token on the stream, but does not change the position on the stream.</li>
<li><b>pop-tkn</b> return the current token on the stream, and increments the position.</li>
<li><b>prev-tkn</b> returns the previous token on the stream, and decrements the position.</li>
<li><b>parse</b> returns the next entire expression that appear on the token stream. The position is set to the first token after the end of the expression.</li>
</ul>
<p><b>Example 1</b></p>
<div class="fragment"><div class="line">(define-syntax println-macro</div>
<div class="line">  (lambda (tkns)</div>
<div class="line">    (strcat &quot;(display &quot; (pop-tkn tkns) &quot;(newline))&quot;)</div>
<div class="line">  )</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">(println-macro 123)</div>
</div><!-- fragment --><p>Initially, the parser reads the define-syntax expression. It evaluates the body of the expression to a lambda object, and saves it in the global stack frame as a macro. Nothing else happens. No meaningful value is returned.</p>
<p>When the parser reaches the last line, it recognizes the macro invocation and calls the macro with the current state of the token stream. The builtin function pop-tkn "pops" the token 123. Then, by using the returned token, the function generates the string</p>
<div class="fragment"><div class="line">&quot;(display 123 (newline))&quot;</div>
</div><!-- fragment --><p>and returns it back to the parser.</p>
<p>The parser receives the string, and parses it again. In the end, a function evaluation expression is constructed and appended to the parse tree.</p>
<p><b>Example 2</b></p>
<p>The macro 'let1' is a version of 'let' that defines only a single local variable.</p>
<div class="fragment"><div class="line">(define-syntax let1</div>
<div class="line">   (lambda (tkns)</div>
<div class="line">     (let ((leftp (pop-tkn tkns))</div>
<div class="line">           (name (pop-tkn tkns))</div>
<div class="line">           (value (parse tkns))</div>
<div class="line">           (rightp (pop-tkn tkns))</div>
<div class="line">           (body (parse tkns)))</div>
<div class="line">       (strcat &quot;(let ((&quot; name &quot; &quot; value &quot; )) &quot; body &quot;)&quot;))))</div>
<div class="line"> </div>
<div class="line">(let1 (a 1) (display a (newline)))</div>
</div><!-- fragment --><p>For comparison, there is a similar example for Scheme in <a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Rules.html">Guile reference</a>. Unfortunately, the ability to parse arbitrary expressions instead of lists increases complexity of macros.</p>
<p><b>Recursion in macros</b></p>
<p>It is possible to use previously defined macros inside a later macro definition, but a macro is not directly available to itself. The new syntax defined by the macro cannot be used inside the macro's own definition. However, there is still a way to implement recursion in macros. Like M4 macro language, the result of a macro is rescanned, and it can contain a macro invocation that refers to the macro itself. The following example generates code that computes factorial.</p>
<p><b>Example 3</b></p>
<div class="fragment"><div class="line">(define-syntax fact-macro</div>
<div class="line">  (lambda (tkns)</div>
<div class="line">    (let ((arg (eval (pop-tkn tkns))))</div>
<div class="line">      (if (= arg 0)</div>
<div class="line">        &quot;1&quot;</div>
<div class="line">        (strcat</div>
<div class="line">          &quot;(* &quot; arg &quot; (fact-macro &quot; (- arg 1) &quot;)))&quot;)))))</div>
</div><!-- fragment --><p>Example trace of the macro invocation (fact-macro 5) and resulting substitutions</p>
<div class="fragment"><div class="line">(fact-macro 5)</div>
<div class="line">(* 5 (fact-macro 4))</div>
<div class="line">(* 5 (* 4 (fact-macro 3)))</div>
<div class="line">(* 5 (* 4 (* 3 (fact-macro 2))))</div>
<div class="line">(* 5 (* 4 (* 3 (* 2 (fact-macro 1)))))</div>
<div class="line">(* 5 (* 4 (* 3 (* 2 (* 1 (fact-macro 0))))))</div>
<div class="line">(* 5 (* 4 (* 3 (* 2 (* 1 1)))))</div>
</div><!-- fragment --><p>When the resulting expression gets evaluated at runtime, it yields 120. The equivalent macro in M4 is</p>
<div class="fragment"><div class="line">define(`factorial&#39;, `ifelse(`$1&#39;, `0&#39;, `1&#39;, `($1 * factorial(eval($1 - 1)))&#39;)&#39;)dnl</div>
<div class="line">factorial(`5&#39;)</div>
</div><!-- fragment --><p>This is intended to be a simple example for demonstrating recursion in macros. It is possible to compute factorial in a macro without making the macro itself recursive. There are also better ways to write the macro if a recursive approach is choosen.</p>
<p>Macros can do everything that ordinary functions can do, including displaying values and doing arbitrary IO operations. The error messages resulting from macro invocations are rarely helpful, so displaying strings can be used as a method to debug macros.</p>
<p><b>Macros based on pattern matching</b></p>
<p>The macros previously described are powerful and can parse any user-defined expression even if the expression contains unbalanced parenthesis. However, this requires complicated code written in an imperative style to directly access the token stream. In most use cases of macros, the ability to parse such complex expressions is unnecessary, and the described macros are inconvenient compared to pattern matching macros of other Lisp dialects. As an alternative, Theory Lisp also provides macros that are based on pattern matching.</p>
<p>A pattern matching macro is defined using 'syntax-rules' which is itself a complex macro in "match.tl" that yields a lambda object. The main limitation of these kind of macros is that they can only contain balanced pairs of parenthesis (), [], {} in macro invocations. For example, (some-macro ([1 2 3] {3 4 (5 6)})) can be a valid invocation, but (some-macro {[}) cannot. Also, string literals are currently not allowed.</p>
<p><b>Example 4</b></p>
<div class="fragment"><div class="line">(define-syntax let1</div>
<div class="line">  (syntax-rules ()</div>
<div class="line">    (</div>
<div class="line">      (let1 (name value) body) ; invocation syntax</div>
<div class="line">      (let ((name value)) body) ; transcription syntax</div>
<div class="line">    )</div>
<div class="line">  )</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">(let1 (x 3) (+ x 4))</div>
</div><!-- fragment --><p>This macro is equivalent to the previous 'let1' macro written in imperative style. Since it does not require any unbalanced pairs of parenthesis, syntax-rules is suitable for this macro. The first expression in the syntax-rules body is called the macro invocation syntax, and the second expression is called the macro transcription syntax. When the given macro invocation matches the macro invocation syntax, the identifiers declared in the invocation syntax are assigned values, and these values are substituted into the transcription syntax.</p>
<p>In this example, name is assigned to x, value is assigned to 3, and body is assigned to the expression (+ x 4). The generated code is</p>
<div class="fragment"><div class="line">(let ((x 3)) (+ x 4))</div>
</div><!-- fragment --><p>which can be verified by running the code in verbose mode.</p>
<p>Warning: In many List dialects, [] and {} are aliases for (). In Theory Lisp, they are recognized as distinct types of parenthesis, and cannot be used interchangeably. If a macro invocation syntax contains {}, using () won't match.</p>
<p><b>Example 6</b></p>
<p>It is possible to write a simple defun macro using pattern matching.</p>
<div class="fragment"><div class="line">(include &quot;util.tl&quot;)</div>
<div class="line"> </div>
<div class="line">(define-syntax defun2</div>
<div class="line">  (syntax-rules (\&zwj;)</div>
<div class="line">    ((defun2 (func-name) body)</div>
<div class="line">     (define func-name (lambda () body)))</div>
<div class="line">    ((defun2 (func-name args ...) body)</div>
<div class="line">     (define func-name (lambda (args ...) body)))</div>
<div class="line">  )</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">(defun2 (func)</div>
<div class="line">  (println &quot;zero arguments&quot;))</div>
<div class="line">(func)</div>
<div class="line"> </div>
<div class="line">(defun2 (func x)</div>
<div class="line"> (println (+ x 1)))</div>
<div class="line">(func 2)</div>
</div><!-- fragment --><p>If a pattern variable is followed by an ellipsis in the invocation syntax, it matches with one or more expressions up to the first closing parenthesis. They are expanded in the transcription syntax by using an ellipsis again.</p>
<p><b>Example 7</b></p>
<div class="fragment"><div class="line">(define-syntax example</div>
<div class="line">  (syntax-rules ()</div>
<div class="line">    ((example (H T ...) ...)</div>
<div class="line">     (cons (list H ...) (list T ...)))))</div>
<div class="line"> </div>
<div class="line">(example (2 -1) (3 0) (4 1) (5 2))</div>
</div><!-- fragment --><p>If an entire parenthesized expression is followed by an ellipsis in the invocation syntax, it also matches with one or more expressions of the same form. In this example, (H T ...) is repeatedly matched with given parenthesized pairs. Inside each expression, H matches the head, and T ... matches the tail. Therefore, the expression yields</p>
<div class="fragment"><div class="line">(cons (list 2 3 4 5) (list -1 0 1 2)</div>
</div><!-- fragment --><p><b>Example 8</b></p>
<p>It is possible to write ellipsis after a parenthesized expression inside the transcription syntax. The entire expression will be repeated until the pattern variables that requires expansion are completely expanded.</p>
<div class="fragment"><div class="line">(define-syntax example</div>
<div class="line">  (syntax-rules ()</div>
<div class="line">    ((example H T ...)</div>
<div class="line">     (list (cons H T) ...))))</div>
<div class="line"> </div>
<div class="line">(example 1 2 3 4 5)</div>
<div class="line">; yields (list (cons 1 2) (cons 1 3) (cons 1 4) (cons 1 5))</div>
</div><!-- fragment --><p><b>define-constexpr</b> and <b>constexpr</b></p>
<p>The interpreter starts after the parse tree has been fully generated, which means that all macro invocations happen before the interpreter starts. Consequently, ordinary definitions are not available inside a macro definition. The following code will cause a parser error.</p>
<div class="fragment"><div class="line">(define factorial</div>
<div class="line">  (lambda (x)</div>
<div class="line">    (if (= x 0)</div>
<div class="line">      1</div>
<div class="line">      (* x (factorial (- x 1))))))</div>
<div class="line"> </div>
<div class="line">(define-syntax macro-factorial</div>
<div class="line">  (lambda (tkns)</div>
<div class="line">    (strcat (factorial (eval (pop-tkn tkns))))))</div>
<div class="line"> </div>
<div class="line">(macro-factorial 5)</div>
</div><!-- fragment --><p>When macro-factorial is invoked, the first define expression has not been interpreted, and there is no 'factorial'. In order to define 'factorial' as an object available to macros, it must be defined using "define-constexpr".</p>
<div class="fragment"><div class="line">(define-constexpr factorial</div>
<div class="line">  (lambda (x)</div>
<div class="line">    (if (= x 0)</div>
<div class="line">      1</div>
<div class="line">      (* x (factorial (- x 1))))))</div>
<div class="line"> </div>
<div class="line">(define-syntax macro-factorial</div>
<div class="line">  (lambda (tkns)</div>
<div class="line">    (strcat (factorial (eval (pop-tkn tkns))))))</div>
<div class="line"> </div>
<div class="line">(macro-factorial 5)</div>
</div><!-- fragment --><p>"constexpr" is used to do computation at parsing time. The multiplication of 3 and 4 does not require any runtime information, so it can be done at parsing time.</p>
<div class="fragment"><div class="line">(define f</div>
<div class="line">  (lambda (x)</div>
<div class="line">    (+ x (constexpr (* 3 4)))))</div>
<div class="line"> </div>
<div class="line">(f 6)</div>
</div><!-- fragment --><p>When this code is run in verbose mode (with -v option as command line parameter) the result is the following:</p>
<div class="fragment"><div class="line">Expression: (define f (lambda (x) (+ x 12)))</div>
<div class="line">Result: (void)</div>
<div class="line">Expression: (f 6)</div>
<div class="line">Result: 18</div>
</div><!-- fragment --><p>The first expression contains the result of the multiplication, and there is no multiplication happening at runtime.</p>
<p>define-constexpr and constexpr are themselves macros defined in "syntax.tl". They use builtin eval function to create this behaviour.</p>
<h1><a class="anchor" id="autotoc_md39"></a>
Try-Catch Expression</h1>
<p>The try-catch expression, together with the builtin function "error" provides a very naive method to create and handle exceptions.</p>
<div class="fragment"><div class="line">(try </div>
<div class="line">  (begin</div>
<div class="line">    (display 1)</div>
<div class="line">    (error &quot;some error&quot;)</div>
<div class="line">    (display 2))</div>
<div class="line">  ) (catch (e)</div>
<div class="line">    (display e)))</div>
</div><!-- fragment --><p>'(e)' in the beginning of the catch block defines a local variable named 'e', which is only visible inside the handler expression. It stores the string message contained in the caught error.</p>
<p>If no exception occurs, the return value of a try-catch expression is equal to the return value of the try block. Otherwise, it yields the return value of the catch block.</p>
<p>When an exception occurs, the execution of the try block terminates immediately, meaning that 2 is not printed. Instead, catch block catches the error and prints its value "some error" to the screen.</p>
<h1><a class="anchor" id="autotoc_md40"></a>
While Expression</h1>
<p>'while' is a macro defined in the library that simulates an imperative 'while' loop with recursion.</p>
<p><b>Example</b></p>
<div class="fragment"><div class="line">(include &quot;macro.tl&quot;)</div>
<div class="line"> </div>
<div class="line">(define i 0)</div>
<div class="line">(while (!= i 10) (begin</div>
<div class="line">  (println i)</div>
<div class="line">  (set! i (+ i 1))))</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md41"></a>
Assert Expression</h1>
<p>'assert' is a macro defined in the library that throws an error if the expression given as argument yields #f. It prints an "Assertion failure" message together with the expression that returned false.</p>
<div class="fragment"><div class="line">(assert (!= 0 1))</div>
</div><!-- fragment --><p>This expression throws an error with message "Assertion failure: (!= 0 1)" </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
